{
  "address": "0x85bC752C944735aEb7E6b4BdC6bF843457fC1C55",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "uint256[]",
          "name": "_expressions",
          "type": "uint256[]"
        }
      ],
      "name": "encodeTree",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256[]",
          "name": "_expressions",
          "type": "uint256[]"
        }
      ],
      "name": "init",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    }
  ],
  "transactionHash": "0x0e85a7e64619426dfe096fd5bddc05602b42c4d3f99114410b72dab0ab895cac",
  "receipt": {
    "to": null,
    "from": "0x793448209Ef713CAe41437C7DaA219b59BEF1A4A",
    "contractAddress": "0x85bC752C944735aEb7E6b4BdC6bF843457fC1C55",
    "transactionIndex": 1,
    "gasUsed": "342888",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x50419e0c2583a129bae057354f55cb1f02a45a2a599a7631dcfa2727f42a1f39",
    "transactionHash": "0x0e85a7e64619426dfe096fd5bddc05602b42c4d3f99114410b72dab0ab895cac",
    "logs": [],
    "blockNumber": 71374229,
    "cumulativeGasUsed": "342888",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "76c3b5d1f613da26b065e9a1ed36d70a",
  "metadata": "{\"compiler\":{\"version\":\"0.8.26+commit.8a97fa7a\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_expressions\",\"type\":\"uint256[]\"}],\"name\":\"encodeTree\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_expressions\",\"type\":\"uint256[]\"}],\"name\":\"init\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/Libraries/Equation.sol\":\"Equation\"},\"evmVersion\":\"cancun\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1},\"remappings\":[]},\"sources\":{\"contracts/Libraries/Equation.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.24;\\n//Claude basically wrote the upgrade\\nimport \\\"solmate/src/utils/SSTORE2.sol\\\";\\n\\nlibrary Equation {\\n    uint8 constant OPCODE_CONST = 0; // 0, 30\\n    uint8 constant OPCODE_VAR = 1; // 1,2 it gives you the 3rd in the array (price,blockNumber,rsi)\\n    uint8 constant OPCODE_SQRT = 2;\\n    uint8 constant OPCODE_NOT = 3;\\n    uint8 constant OPCODE_ADD = 4;\\n    uint8 constant OPCODE_SUB = 5;\\n    uint8 constant OPCODE_MUL = 6;\\n    uint8 constant OPCODE_DIV = 7;\\n    uint8 constant OPCODE_EXP = 8;\\n    uint8 constant OPCODE_PCT = 9;\\n    uint8 constant OPCODE_EQ = 10; //equals\\n    uint8 constant OPCODE_NE = 11; //not equals\\n    uint8 constant OPCODE_LT = 12;\\n    uint8 constant OPCODE_GT = 13;\\n    uint8 constant OPCODE_LE = 14; //less than or equal to\\n    uint8 constant OPCODE_GE = 15; //greater than or equal to\\n    uint8 constant OPCODE_AND = 16; //takes two bools returns one bool\\n    uint8 constant OPCODE_OR = 17; //takes two bools return one bool\\n    uint8 constant OPCODE_IF = 18; // Takes one bool returns 2 potential outputs\\n    uint8 constant OPCODE_INVALID = 19;\\n\\n    //if x2 < 50 then 100 else 0\\n    //(conditional) ?(return this) :(else this)\\n    //You can string together if statements, but else is the required end\\n    // 18, 14, 1,2, 0,50,0,100,18,\\n    function init(\\n        uint256[] calldata _expressions\\n    ) external pure returns (bytes memory) {\\n        require(\\n            _expressions.length > 0 && _expressions.length < 256,\\n            \\\"Invalid expression length\\\"\\n        );\\n        return encodeTree(_expressions);\\n    }\\n\\n    function encodeTree(\\n        uint256[] calldata _expressions\\n    ) public pure returns (bytes memory) {\\n        bytes memory encoded = new bytes(_expressions.length * 33); // Max possible size\\n        uint256 encodedLength = 0;\\n\\n        for (uint256 i = 0; i < _expressions.length; ) {\\n            uint8 opcode = uint8(_expressions[i]);\\n            require(opcode < OPCODE_INVALID, \\\"Invalid opcode\\\");\\n            encoded[encodedLength++] = bytes1(opcode);\\n\\n            if (opcode == OPCODE_CONST || opcode == OPCODE_VAR) {\\n                require(\\n                    i + 1 < _expressions.length,\\n                    \\\"Missing value for CONST or VAR\\\"\\n                );\\n                uint256 value = _expressions[++i];\\n                for (uint8 j = 0; j < 32; j++) {\\n                    encoded[encodedLength++] = bytes1(\\n                        uint8(value >> (8 * (31 - j)))\\n                    );\\n                }\\n            }\\n            i++;\\n        }\\n\\n        bytes memory result = new bytes(encodedLength);\\n        for (uint256 i = 0; i < encodedLength; i++) {\\n            result[i] = encoded[i];\\n        }\\n        return result;\\n    }\\n\\n    function calculate(\\n        bytes memory encodedTree,\\n        uint256[] calldata xValue\\n    ) internal pure returns (uint256) {\\n        (uint256 result, ) = evaluateNode(encodedTree, 0, xValue);\\n        return result;\\n    }\\n\\n    function evaluateNode(\\n        bytes memory encodedTree,\\n        uint256 startIndex,\\n        uint256[] calldata xValue\\n    ) private pure returns (uint256, uint256) {\\n        uint8 opcode = uint8(encodedTree[startIndex]);\\n        uint256 nextIndex = startIndex + 1;\\n\\n        if (opcode == OPCODE_CONST) {\\n            return (decodeUint256(encodedTree, nextIndex), nextIndex + 32);\\n        }\\n        if (opcode == OPCODE_VAR) {\\n            uint256 varIndex = decodeUint256(encodedTree, nextIndex);\\n            require(varIndex < xValue.length, \\\"Invalid variable index\\\");\\n            return (xValue[varIndex], nextIndex + 32);\\n        }\\n        uint256 a;\\n        uint256 b;\\n        (a, nextIndex) = evaluateNode(encodedTree, nextIndex, xValue);\\n        if (opcode == OPCODE_SQRT) return (sqrt(a), nextIndex);\\n        if (opcode == OPCODE_NOT) return (a == 0 ? 1 : 0, nextIndex);\\n\\n        (b, nextIndex) = evaluateNode(encodedTree, nextIndex, xValue);\\n        if (opcode == OPCODE_ADD) return (a + b, nextIndex);\\n        if (opcode == OPCODE_SUB) return (a - b, nextIndex);\\n        if (opcode == OPCODE_MUL) return (a * b, nextIndex);\\n        if (opcode == OPCODE_DIV) return (a / b, nextIndex);\\n        if (opcode == OPCODE_EXP) return (power(a, b), nextIndex);\\n        if (opcode == OPCODE_PCT) return ((a * b) / 1e18, nextIndex);\\n        if (opcode == OPCODE_EQ) return (a == b ? 1 : 0, nextIndex);\\n        if (opcode == OPCODE_NE) return (a != b ? 1 : 0, nextIndex);\\n        if (opcode == OPCODE_LT) return (a < b ? 1 : 0, nextIndex);\\n        if (opcode == OPCODE_GT) return (a > b ? 1 : 0, nextIndex);\\n        if (opcode == OPCODE_LE) return (a <= b ? 1 : 0, nextIndex);\\n        if (opcode == OPCODE_GE) return (a >= b ? 1 : 0, nextIndex);\\n        if (opcode == OPCODE_AND)\\n            return ((a != 0 && b != 0) ? 1 : 0, nextIndex);\\n        if (opcode == OPCODE_OR) return ((a != 0 || b != 0) ? 1 : 0, nextIndex);\\n\\n        if (opcode == OPCODE_IF) {\\n            uint256 c;\\n            (c, nextIndex) = evaluateNode(encodedTree, nextIndex, xValue);\\n            return (a != 0 ? b : c, nextIndex);\\n        }\\n\\n        revert(\\\"Invalid opcode\\\");\\n    }\\n\\n    function decodeUint256(\\n        bytes memory data,\\n        uint256 startIndex\\n    ) private pure returns (uint256) {\\n        require(startIndex + 32 <= data.length, \\\"Out of bounds\\\");\\n        uint256 value;\\n        assembly {\\n            value := mload(add(add(data, 0x20), startIndex))\\n        }\\n        return value;\\n    }\\n\\n    function sqrt(uint256 x) private pure returns (uint256 y) {\\n        if (x == 0) return 0;\\n        else if (x <= 3) return 1;\\n        uint256 z = (x + 1) / 2;\\n        y = x;\\n        while (z < y) {\\n            y = z;\\n            z = (x / z + z) / 2;\\n        }\\n    }\\n\\n    function power(\\n        uint256 base,\\n        uint256 exponent\\n    ) private pure returns (uint256) {\\n        if (exponent == 0) return 1;\\n        uint256 result = 1;\\n        while (exponent > 0) {\\n            if (exponent % 2 == 1) result *= base;\\n            base *= base;\\n            exponent /= 2;\\n        }\\n        return result;\\n    }\\n}\\n\",\"keccak256\":\"0x75197aecf2108be5b0a03b35eb76e7f6423e7fe6b70366c99a525d7ad6753647\",\"license\":\"Apache-2.0\"},\"solmate/src/utils/SSTORE2.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Read and write to persistent storage at a fraction of the cost.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SSTORE2.sol)\\n/// @author Modified from 0xSequence (https://github.com/0xSequence/sstore2/blob/master/contracts/SSTORE2.sol)\\nlibrary SSTORE2 {\\n    uint256 internal constant DATA_OFFSET = 1; // We skip the first byte as it's a STOP opcode to ensure the contract can't be called.\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               WRITE LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function write(bytes memory data) internal returns (address pointer) {\\n        // Prefix the bytecode with a STOP opcode to ensure it cannot be called.\\n        bytes memory runtimeCode = abi.encodePacked(hex\\\"00\\\", data);\\n\\n        bytes memory creationCode = abi.encodePacked(\\n            //---------------------------------------------------------------------------------------------------------------//\\n            // Opcode  | Opcode + Arguments  | Description  | Stack View                                                     //\\n            //---------------------------------------------------------------------------------------------------------------//\\n            // 0x60    |  0x600B             | PUSH1 11     | codeOffset                                                     //\\n            // 0x59    |  0x59               | MSIZE        | 0 codeOffset                                                   //\\n            // 0x81    |  0x81               | DUP2         | codeOffset 0 codeOffset                                        //\\n            // 0x38    |  0x38               | CODESIZE     | codeSize codeOffset 0 codeOffset                               //\\n            // 0x03    |  0x03               | SUB          | (codeSize - codeOffset) 0 codeOffset                           //\\n            // 0x80    |  0x80               | DUP          | (codeSize - codeOffset) (codeSize - codeOffset) 0 codeOffset   //\\n            // 0x92    |  0x92               | SWAP3        | codeOffset (codeSize - codeOffset) 0 (codeSize - codeOffset)   //\\n            // 0x59    |  0x59               | MSIZE        | 0 codeOffset (codeSize - codeOffset) 0 (codeSize - codeOffset) //\\n            // 0x39    |  0x39               | CODECOPY     | 0 (codeSize - codeOffset)                                      //\\n            // 0xf3    |  0xf3               | RETURN       |                                                                //\\n            //---------------------------------------------------------------------------------------------------------------//\\n            hex\\\"60_0B_59_81_38_03_80_92_59_39_F3\\\", // Returns all code in the contract except for the first 11 (0B in hex) bytes.\\n            runtimeCode // The bytecode we want the contract to have after deployment. Capped at 1 byte less than the code size limit.\\n        );\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Deploy a new contract with the generated creation code.\\n            // We start 32 bytes into the code to avoid copying the byte length.\\n            pointer := create(0, add(creationCode, 32), mload(creationCode))\\n        }\\n\\n        require(pointer != address(0), \\\"DEPLOYMENT_FAILED\\\");\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               READ LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function read(address pointer) internal view returns (bytes memory) {\\n        return readBytecode(pointer, DATA_OFFSET, pointer.code.length - DATA_OFFSET);\\n    }\\n\\n    function read(address pointer, uint256 start) internal view returns (bytes memory) {\\n        start += DATA_OFFSET;\\n\\n        return readBytecode(pointer, start, pointer.code.length - start);\\n    }\\n\\n    function read(\\n        address pointer,\\n        uint256 start,\\n        uint256 end\\n    ) internal view returns (bytes memory) {\\n        start += DATA_OFFSET;\\n        end += DATA_OFFSET;\\n\\n        require(pointer.code.length >= end, \\\"OUT_OF_BOUNDS\\\");\\n\\n        return readBytecode(pointer, start, end - start);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                          INTERNAL HELPER LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function readBytecode(\\n        address pointer,\\n        uint256 start,\\n        uint256 size\\n    ) private view returns (bytes memory data) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            data := mload(0x40)\\n\\n            // Update the free memory pointer to prevent overriding our data.\\n            // We use and(x, not(31)) as a cheaper equivalent to sub(x, mod(x, 32)).\\n            // Adding 31 to size and running the result through the logic above ensures\\n            // the memory pointer remains word-aligned, following the Solidity convention.\\n            mstore(0x40, add(data, and(add(add(size, 32), 31), not(31))))\\n\\n            // Store the size of the data in the first 32 byte chunk of free memory.\\n            mstore(data, size)\\n\\n            // Copy the code into memory right after the 32 bytes we used to store the size.\\n            extcodecopy(pointer, add(data, 32), start, size)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xc5359c92365c550c418725fc534a538426ea8f6e7f6c06c0a9d66647d864469d\",\"license\":\"AGPL-3.0-only\"}},\"version\":1}",
  "bytecode": "0x61053b610034600b8282823980515f1a607314602857634e487b7160e01b5f525f60045260245ffd5b305f52607381538281f3fe730000000000000000000000000000000000000000301460806040526004361061003f575f3560e01c8063d88b06db14610043578063f6a7fffb1461006c575b5f80fd5b6100566100513660046103a7565b61007f565b6040516100639190610416565b60405180910390f35b61005661007a3660046103a7565b6100f1565b60608115801590610091575061010082105b6100de5760405162461bcd60e51b8152602060048201526019602482015278092dcecc2d8d2c840caf0e0e4cae6e6d2dedc40d8cadccee8d603b1b60448201526064015b60405180910390fd5b6100e883836100f1565b90505b92915050565b60605f6100ff83602161045f565b6001600160401b0381111561011657610116610476565b6040519080825280601f01601f191660200182016040528015610140576020820181803683370190505b5090505f805b848110156102ff575f8686838181106101615761016161048a565b905060200201359050601360ff168160ff16106101b15760405162461bcd60e51b815260206004820152600e60248201526d496e76616c6964206f70636f646560901b60448201526064016100d5565b8060f81b8484806101c19061049e565b9550815181106101d3576101d361048a565b60200101906001600160f81b03191690815f1a90535060ff811615806101fc575060ff81166001145b156102ec578561020d8360016104b6565b1061025a5760405162461bcd60e51b815260206004820152601e60248201527f4d697373696e672076616c756520666f7220434f4e5354206f7220564152000060448201526064016100d5565b5f87876102668561049e565b9450848181106102785761027861048a565b9050602002013590505f5b60208160ff1610156102e95761029a81601f6104c9565b6102a59060086104e2565b60ff1682901c60f81b86866102b98161049e565b9750815181106102cb576102cb61048a565b60200101906001600160f81b03191690815f1a905350600101610283565b50505b816102f68161049e565b92505050610146565b505f816001600160401b0381111561031957610319610476565b6040519080825280601f01601f191660200182016040528015610343576020820181803683370190505b5090505f5b8281101561039d578381815181106103625761036261048a565b602001015160f81c60f81b82828151811061037f5761037f61048a565b60200101906001600160f81b03191690815f1a905350600101610348565b5095945050505050565b5f80602083850312156103b8575f80fd5b82356001600160401b038111156103cd575f80fd5b8301601f810185136103dd575f80fd5b80356001600160401b038111156103f2575f80fd5b8560208260051b8401011115610406575f80fd5b6020919091019590945092505050565b602081525f82518060208401528060208501604085015e5f604082850101526040601f19601f83011684010191505092915050565b634e487b7160e01b5f52601160045260245ffd5b80820281158282048414176100eb576100eb61044b565b634e487b7160e01b5f52604160045260245ffd5b634e487b7160e01b5f52603260045260245ffd5b5f600182016104af576104af61044b565b5060010190565b808201808211156100eb576100eb61044b565b60ff82811682821603908111156100eb576100eb61044b565b60ff81811683821602908116908181146104fe576104fe61044b565b509291505056fea2646970667358221220fb3e935d16bb76ce3e60aeef73d246b14f521a2d71407f82ffd9e4ab929c1b3564736f6c634300081a0033",
  "deployedBytecode": "0x730000000000000000000000000000000000000000301460806040526004361061003f575f3560e01c8063d88b06db14610043578063f6a7fffb1461006c575b5f80fd5b6100566100513660046103a7565b61007f565b6040516100639190610416565b60405180910390f35b61005661007a3660046103a7565b6100f1565b60608115801590610091575061010082105b6100de5760405162461bcd60e51b8152602060048201526019602482015278092dcecc2d8d2c840caf0e0e4cae6e6d2dedc40d8cadccee8d603b1b60448201526064015b60405180910390fd5b6100e883836100f1565b90505b92915050565b60605f6100ff83602161045f565b6001600160401b0381111561011657610116610476565b6040519080825280601f01601f191660200182016040528015610140576020820181803683370190505b5090505f805b848110156102ff575f8686838181106101615761016161048a565b905060200201359050601360ff168160ff16106101b15760405162461bcd60e51b815260206004820152600e60248201526d496e76616c6964206f70636f646560901b60448201526064016100d5565b8060f81b8484806101c19061049e565b9550815181106101d3576101d361048a565b60200101906001600160f81b03191690815f1a90535060ff811615806101fc575060ff81166001145b156102ec578561020d8360016104b6565b1061025a5760405162461bcd60e51b815260206004820152601e60248201527f4d697373696e672076616c756520666f7220434f4e5354206f7220564152000060448201526064016100d5565b5f87876102668561049e565b9450848181106102785761027861048a565b9050602002013590505f5b60208160ff1610156102e95761029a81601f6104c9565b6102a59060086104e2565b60ff1682901c60f81b86866102b98161049e565b9750815181106102cb576102cb61048a565b60200101906001600160f81b03191690815f1a905350600101610283565b50505b816102f68161049e565b92505050610146565b505f816001600160401b0381111561031957610319610476565b6040519080825280601f01601f191660200182016040528015610343576020820181803683370190505b5090505f5b8281101561039d578381815181106103625761036261048a565b602001015160f81c60f81b82828151811061037f5761037f61048a565b60200101906001600160f81b03191690815f1a905350600101610348565b5095945050505050565b5f80602083850312156103b8575f80fd5b82356001600160401b038111156103cd575f80fd5b8301601f810185136103dd575f80fd5b80356001600160401b038111156103f2575f80fd5b8560208260051b8401011115610406575f80fd5b6020919091019590945092505050565b602081525f82518060208401528060208501604085015e5f604082850101526040601f19601f83011684010191505092915050565b634e487b7160e01b5f52601160045260245ffd5b80820281158282048414176100eb576100eb61044b565b634e487b7160e01b5f52604160045260245ffd5b634e487b7160e01b5f52603260045260245ffd5b5f600182016104af576104af61044b565b5060010190565b808201808211156100eb576100eb61044b565b60ff82811682821603908111156100eb576100eb61044b565b60ff81811683821602908116908181146104fe576104fe61044b565b509291505056fea2646970667358221220fb3e935d16bb76ce3e60aeef73d246b14f521a2d71407f82ffd9e4ab929c1b3564736f6c634300081a0033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}