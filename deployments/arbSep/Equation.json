{
  "address": "0xB2ddF618505A315890b0040FEa441BB7A2e2C68b",
  "abi": [],
  "transactionHash": "0x5c2a34430993f9e24fba7bb9dad6766ac31bf3cef23ce45279b8e8ae7449b163",
  "receipt": {
    "to": null,
    "from": "0x793448209Ef713CAe41437C7DaA219b59BEF1A4A",
    "contractAddress": "0xB2ddF618505A315890b0040FEa441BB7A2e2C68b",
    "transactionIndex": 1,
    "gasUsed": "912606",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x3c939151957d1877c8dd1f20cc97c518efe6dce676aea34211807175f6dcc123",
    "transactionHash": "0x5c2a34430993f9e24fba7bb9dad6766ac31bf3cef23ce45279b8e8ae7449b163",
    "logs": [],
    "blockNumber": 68107301,
    "cumulativeGasUsed": "912606",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "2525b1a6ad19a88bb3c023d325a984f3",
  "metadata": "{\"compiler\":{\"version\":\"0.8.24+commit.e11b9ed9\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"init(Equation.Node[] storage,uint256[])\":{\"details\":\"Initialize equation by array of opcodes/values in prefix order. Array is read as if it is the *pre-order* traversal of the expression tree.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"calculate(Equation.Node[] storage,uint256[])\":{\"notice\":\"Calculate the Y position from the X position for this equation.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/Equation.sol\":\"Equation\"},\"evmVersion\":\"cancun\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":100},\"remappings\":[]},\"sources\":{\"contracts/Equation.sol\":{\"content\":\"// SPDX-License-Identifier:  Apache-2.0 license\\npragma solidity 0.8.24;\\n\\n// import \\\"../../bancor/BancorPower.sol\\\";\\n\\nlibrary Equation {\\n    /// An expression tree is encoded as a set of nodes, with root node having index zero. Each node has 3 values:\\n    ///  1. opcode: the expression that the node represents. See table below.\\n    /// +--------+----------------------------------------+------+------------+\\n    /// | Opcode |              Description               | i.e. | # children |\\n    /// +--------+----------------------------------------+------+------------+\\n    /// |   00   | Integer Constant                       |   c  |      0     |\\n    /// |   01   | Variable                               |   X  |      0     |\\n    /// |   02   | Arithmetic Square Root                 |   \\u221a  |      1     |\\n    /// |   03   | Boolean Not Condition                  |   !  |      1     |\\n    /// |   04   | Arithmetic Addition                    |   +  |      2     |\\n    /// |   05   | Arithmetic Subtraction                 |   -  |      2     |\\n    /// |   06   | Arithmetic Multiplication              |   *  |      2     |\\n    /// |   07   | Arithmetic Division                    |   /  |      2     |\\n    /// |   08   | Arithmetic Exponentiation              |  **  |      2     |\\n    /// |   09   | Arithmetic Percentage* (see below)     |   %  |      2     |\\n    /// |   10   | Arithmetic Equal Comparison            |  ==  |      2     |\\n    /// |   11   | Arithmetic Non-Equal Comparison        |  !=  |      2     |\\n    /// |   12   | Arithmetic Less-Than Comparison        |  <   |      2     |\\n    /// |   13   | Arithmetic Greater-Than Comparison     |  >   |      2     |\\n    /// |   14   | Arithmetic Non-Greater-Than Comparison |  <=  |      2     |\\n    /// |   15   | Arithmetic Non-Less-Than Comparison    |  >=  |      2     |\\n    /// |   16   | Boolean And Condition                  |  &&  |      2     |\\n    /// |   17   | Boolean Or Condition                   |  ||  |      2     |\\n    /// |   18   | Ternary Operation                      |  ?:  |      3     |\\n    /// |   19   | Bancor's log** (see below)             |      |      3     |\\n    /// |   20   | Bancor's power*** (see below)          |      |      4     |\\n    /// +--------+----------------------------------------+------+------------+\\n    ///  2. children: the list of node indices of this node's sub-expressions. Different opcode nodes will have different\\n    ///     number of children.\\n    ///  3. value: the value inside the node. Currently this is only relevant for Integer Constant (Opcode 00).\\n    /// (*) Arithmetic percentage is computed by multiplying the left-hand side value with the right-hand side,\\n    ///     and divide the result by 10^18, rounded down to uint256 integer.\\n    /// (**) Using BancorFormula, the opcode computes log of fractional numbers. However, this fraction's value must\\n    ///     be more than 1. (baseN / baseD >= 1). The opcode takes 3 childrens(c, baseN, baseD), and computes\\n    ///     (c * log(baseN / baseD)) limitation is in range of 1 <= baseN / baseD <= 58774717541114375398436826861112283890\\n    ///     (= 1e76/FIXED_1), where FIXED_1 defined in BancorPower.sol\\n    /// (***) Using BancorFomula, the opcode computes exponential of fractional numbers. The opcode takes 4 children\\n    ///     (c,baseN,baseD,expV), and computes (c * ((baseN / baseD) ^ (expV / 1e6))). See implementation for the\\n    ///     limitation of the each value's domain. The end result must be in uint256 range.\\n    struct Node {\\n        uint8 opcode;\\n        uint8 child0;\\n        uint8 child1;\\n        uint8 child2;\\n        uint8 child3;\\n        uint256 value;\\n    }\\n\\n    enum ExprType {\\n        Invalid,\\n        Math,\\n        Boolean\\n    }\\n\\n    uint8 constant OPCODE_CONST = 0;\\n    uint8 constant OPCODE_VAR = 1;\\n    uint8 constant OPCODE_SQRT = 2;\\n    uint8 constant OPCODE_NOT = 3;\\n    uint8 constant OPCODE_ADD = 4;\\n    uint8 constant OPCODE_SUB = 5;\\n    uint8 constant OPCODE_MUL = 6;\\n    uint8 constant OPCODE_DIV = 7;\\n    uint8 constant OPCODE_EXP = 8;\\n    uint8 constant OPCODE_PCT = 9;\\n    uint8 constant OPCODE_EQ = 10;\\n    uint8 constant OPCODE_NE = 11;\\n    uint8 constant OPCODE_LT = 12;\\n    uint8 constant OPCODE_GT = 13;\\n    uint8 constant OPCODE_LE = 14;\\n    uint8 constant OPCODE_GE = 15;\\n    uint8 constant OPCODE_AND = 16;\\n    uint8 constant OPCODE_OR = 17;\\n    uint8 constant OPCODE_IF = 18;\\n    uint8 constant OPCODE_BANCOR_LOG = 19;\\n    uint8 constant OPCODE_BANCOR_POWER = 20;\\n    uint8 constant OPCODE_INVALID = 21;\\n\\n    /// @dev Initialize equation by array of opcodes/values in prefix order. Array\\n    /// is read as if it is the *pre-order* traversal of the expression tree.\\n    function init(\\n        Node[] storage self,\\n        uint256[] calldata _expressions\\n    ) external {\\n        require(self.length == 0);\\n        require(_expressions.length < 256);\\n        for (uint8 idx = 0; idx < _expressions.length; ++idx) {\\n            uint256 opcode = _expressions[idx];\\n            require(opcode < OPCODE_INVALID);\\n            Node memory node;\\n            node.opcode = uint8(opcode);\\n            if (opcode == OPCODE_CONST || opcode == OPCODE_VAR) {\\n                node.value = _expressions[++idx];\\n            }\\n            self.push(node);\\n        }\\n        (uint8 lastNodeIndex, ) = populateTree(self, 0);\\n        require(lastNodeIndex == self.length - 1);\\n    }\\n\\n    /// Calculate the Y position from the X position for this equation.\\n    function calculate(\\n        Node[] storage self,\\n        uint256[] calldata xValue\\n    ) external view returns (uint256) {\\n        return solveMath(self, 0, xValue);\\n    }\\n\\n    /// Return the number of children the given opcode node has.\\n    function getChildrenCount(uint8 opcode) private pure returns (uint8) {\\n        if (opcode <= OPCODE_VAR) {\\n            return 0;\\n        } else if (opcode <= OPCODE_NOT) {\\n            return 1;\\n        } else if (opcode <= OPCODE_OR) {\\n            return 2;\\n        } else if (opcode <= OPCODE_BANCOR_LOG) {\\n            return 3;\\n        } else if (opcode <= OPCODE_BANCOR_POWER) {\\n            return 4;\\n        }\\n        revert();\\n    }\\n\\n    /// Check whether the given opcode and list of expression types match. Revert on failure.\\n    function checkExprType(\\n        uint8 opcode,\\n        ExprType[] memory types\\n    ) private pure returns (ExprType) {\\n        if (opcode <= OPCODE_VAR) {\\n            return ExprType.Math;\\n        } else if (opcode == OPCODE_SQRT) {\\n            require(types[0] == ExprType.Math);\\n            return ExprType.Math;\\n        } else if (opcode == OPCODE_NOT) {\\n            require(types[0] == ExprType.Boolean);\\n            return ExprType.Boolean;\\n        } else if (opcode >= OPCODE_ADD && opcode <= OPCODE_PCT) {\\n            require(types[0] == ExprType.Math);\\n            require(types[1] == ExprType.Math);\\n            return ExprType.Math;\\n        } else if (opcode >= OPCODE_EQ && opcode <= OPCODE_GE) {\\n            require(types[0] == ExprType.Math);\\n            require(types[1] == ExprType.Math);\\n            return ExprType.Boolean;\\n        } else if (opcode >= OPCODE_AND && opcode <= OPCODE_OR) {\\n            require(types[0] == ExprType.Boolean);\\n            require(types[1] == ExprType.Boolean);\\n            return ExprType.Boolean;\\n        } else if (opcode == OPCODE_IF) {\\n            require(types[0] == ExprType.Boolean);\\n            require(types[1] != ExprType.Invalid);\\n            require(types[1] == types[2]);\\n            return types[1];\\n        } else if (opcode == OPCODE_BANCOR_LOG) {\\n            require(types[0] == ExprType.Math);\\n            require(types[1] == ExprType.Math);\\n            require(types[2] == ExprType.Math);\\n            return ExprType.Math;\\n        } else if (opcode == OPCODE_BANCOR_POWER) {\\n            require(types[0] == ExprType.Math);\\n            require(types[1] == ExprType.Math);\\n            require(types[2] == ExprType.Math);\\n            require(types[3] == ExprType.Math);\\n            return ExprType.Math;\\n        }\\n        revert();\\n    }\\n\\n    /// Helper function to recursively populate node infoMaprmation following the given pre-order\\n    /// node list. It inspects the opcode and recursively call populateTree(s) accordingly.\\n    /// @param self storage pointer to equation data to build tree.\\n    /// @param currentNodeIndex the index of the current node to populate infoMap.\\n    /// @return An (uint8, bool). The first value represents the last  (highest/rightmost) node\\n    /// index of the current subtree. The second value indicates the type of this subtree.\\n    function populateTree(\\n        Node[] storage self,\\n        uint8 currentNodeIndex\\n    ) private returns (uint8, ExprType) {\\n        require(currentNodeIndex < self.length);\\n        Node storage node = self[currentNodeIndex];\\n        uint8 opcode = node.opcode;\\n        uint8 childrenCount = getChildrenCount(opcode);\\n        ExprType[] memory childrenTypes = new ExprType[](childrenCount);\\n        uint8 lastNodeIdx = currentNodeIndex;\\n        for (uint8 idx = 0; idx < childrenCount; ++idx) {\\n            if (idx == 0) node.child0 = lastNodeIdx + 1;\\n            else if (idx == 1) node.child1 = lastNodeIdx + 1;\\n            else if (idx == 2) node.child2 = lastNodeIdx + 1;\\n            else if (idx == 3) node.child3 = lastNodeIdx + 1;\\n            else revert();\\n            (lastNodeIdx, childrenTypes[idx]) = populateTree(\\n                self,\\n                lastNodeIdx + 1\\n            );\\n        }\\n        ExprType exprType = checkExprType(opcode, childrenTypes);\\n        return (lastNodeIdx, exprType);\\n    }\\n\\n    function solveMath(\\n        Node[] storage self,\\n        uint8 nodeIdx,\\n        uint256[] memory xValues\\n    ) private view returns (uint256) {\\n        Node storage node = self[nodeIdx];\\n        uint8 opcode = node.opcode;\\n        if (opcode == OPCODE_CONST) {\\n            return node.value;\\n        } else if (opcode == OPCODE_VAR) {\\n            require(node.value < xValues.length, \\\"Invalid variable index\\\");\\n            return xValues[node.value];\\n        } else if (opcode == OPCODE_SQRT) {\\n            uint256 childValue = solveMath(self, node.child0, xValues);\\n            uint256 temp = (childValue + 1) / 2;\\n            uint256 result = childValue;\\n            while (temp < result) {\\n                result = temp;\\n                temp = (childValue / temp + temp) / 2;\\n            }\\n            return result;\\n        } else if (opcode >= OPCODE_ADD && opcode <= OPCODE_PCT) {\\n            uint256 leftValue = solveMath(self, node.child0, xValues);\\n            uint256 rightValue = solveMath(self, node.child1, xValues);\\n            if (opcode == OPCODE_ADD) {\\n                return leftValue + rightValue;\\n            } else if (opcode == OPCODE_SUB) {\\n                return leftValue - rightValue;\\n            } else if (opcode == OPCODE_MUL) {\\n                return leftValue * rightValue;\\n            } else if (opcode == OPCODE_DIV) {\\n                return leftValue / rightValue;\\n            } else if (opcode == OPCODE_EXP) {\\n                uint256 power = rightValue;\\n                uint256 expResult = 1;\\n                for (uint256 idx = 0; idx < power; ++idx) {\\n                    expResult = expResult * leftValue;\\n                }\\n                return expResult;\\n            } else if (opcode == OPCODE_PCT) {\\n                return (leftValue * rightValue) / 1e18;\\n            }\\n        } else if (opcode == OPCODE_IF) {\\n            bool condValue = solveBool(self, node.child0, xValues);\\n            if (condValue) return solveMath(self, node.child1, xValues);\\n            else return solveMath(self, node.child2, xValues);\\n        } else if (opcode == OPCODE_BANCOR_LOG) {\\n            revert();\\n        } else if (opcode == OPCODE_BANCOR_POWER) {\\n            revert();\\n        }\\n        revert();\\n    }\\n\\n    function solveBool(\\n        Node[] storage self,\\n        uint8 nodeIdx,\\n        uint256[] memory xValues\\n    ) private view returns (bool) {\\n        Node storage node = self[nodeIdx];\\n        uint8 opcode = node.opcode;\\n        if (opcode == OPCODE_NOT) {\\n            return !solveBool(self, node.child0, xValues);\\n        } else if (opcode >= OPCODE_EQ && opcode <= OPCODE_GE) {\\n            uint256 leftValue = solveMath(self, node.child0, xValues);\\n            uint256 rightValue = solveMath(self, node.child1, xValues);\\n            if (opcode == OPCODE_EQ) {\\n                return leftValue == rightValue;\\n            } else if (opcode == OPCODE_NE) {\\n                return leftValue != rightValue;\\n            } else if (opcode == OPCODE_LT) {\\n                return leftValue < rightValue;\\n            } else if (opcode == OPCODE_GT) {\\n                return leftValue > rightValue;\\n            } else if (opcode == OPCODE_LE) {\\n                return leftValue <= rightValue;\\n            } else if (opcode == OPCODE_GE) {\\n                return leftValue >= rightValue;\\n            }\\n        } else if (opcode >= OPCODE_AND && opcode <= OPCODE_OR) {\\n            bool leftBoolValue = solveBool(self, node.child0, xValues);\\n            if (opcode == OPCODE_AND) {\\n                if (leftBoolValue) return solveBool(self, node.child1, xValues);\\n                else return false;\\n            } else if (opcode == OPCODE_OR) {\\n                if (leftBoolValue) return true;\\n                else return solveBool(self, node.child1, xValues);\\n            }\\n        } else if (opcode == OPCODE_IF) {\\n            bool condValue = solveBool(self, node.child0, xValues);\\n            if (condValue) return solveBool(self, node.child1, xValues);\\n            else return solveBool(self, node.child2, xValues);\\n        }\\n        revert();\\n    }\\n}\\n\",\"keccak256\":\"0xdcd8b791cbdc0659884b7eab9efada939cd50c95e368c0ea24d2d33a83336765\",\"license\":\"Apache-2.0 license\"}},\"version\":1}",
  "bytecode": "0x610f89610035600b8282823980515f1a60731461002957634e487b7160e01b5f525f60045260245ffd5b305f52607381538281f3fe730000000000000000000000000000000000000000301460806040526004361061003f575f3560e01c80638e501fc714610043578063b15b56f514610064575b5f80fd5b81801561004e575f80fd5b5061006261005d366004610df8565b610089565b005b610077610072366004610df8565b61022a565b60405190815260200160405180910390f35b825415610094575f80fd5b61010081106100a1575f80fd5b5f5b60ff81168211156101f9575f83838360ff168181106100c4576100c4610e70565b905060200201359050601560ff1681106100dc575f80fd5b6040805160c0810182525f60208201819052918101829052606081018290526080810182905260a081019190915260ff8216815281158061011d5750600182145b1561015157848461012d85610e98565b94508460ff1681811061014257610142610e70565b602002919091013560a0830152505b8554600180820188555f888152602090819020845160029094020180549185015160408601516060870151608088015160ff97881661ffff1990961695909517610100938816939093029290921763ffff00001916620100009187169190910263ff0000001916176301000000918616919091021764ff000000001916640100000000949092169390930217825560a090920151910155506101f281610e98565b90506100a3565b505f610205845f610272565b50845490915061021790600190610eb6565b8160ff1614610224575f80fd5b50505050565b5f610268845f8585808060200260200160405190810160405280939291908181526020018383602002808284375f9201919091525061045f92505050565b90505b9392505050565b81545f90819060ff841610610285575f80fd5b5f848460ff168154811061029b5761029b610e70565b5f91825260208220600290910201805490925060ff16906102bb82610740565b90505f8160ff1667ffffffffffffffff8111156102da576102da610ec9565b604051908082528060200260200182016040528015610303578160200160208202803683370190505b509050865f5b8360ff168160ff161015610442578060ff165f036103475761032c826001610edd565b865460ff919091166101000261ff00199091161786556103e2565b8060ff1660010361037a5761035d826001610edd565b865460ff91909116620100000262ff0000199091161786556103e2565b8060ff166002036103af57610390826001610edd565b865460ff9190911663010000000263ff000000199091161786556103e2565b8060ff1660030361003f576103c5826001610edd565b865460ff919091166401000000000264ff00000000199091161786555b6103f68a6103f1846001610edd565b610272565b848360ff168151811061040b5761040b610e70565b6020026020010181600281111561042457610424610ef6565b600281111561043557610435610ef6565b9052509150600101610309565b505f61044e858461079f565b919a91995090975050505050505050565b5f80848460ff168154811061047657610476610e70565b5f9182526020909120600290910201805490915060ff168061049e575060010154905061026b565b5f1960ff8216016105215783518260010154106104fa5760405162461bcd60e51b8152602060048201526016602482015275092dcecc2d8d2c840ecc2e4d2c2c4d8ca40d2dcc8caf60531b604482015260640160405180910390fd5b8382600101548151811061051057610510610e70565b60200260200101519250505061026b565b60011960ff8216016105a15781545f90610545908890610100900460ff168761045f565b90505f6002610555836001610f0a565b61055f9190610f1d565b9050815b8082101561059557508060028161057a8186610f1d565b6105849190610f0a565b61058e9190610f1d565b9150610563565b945061026b9350505050565b600460ff8216108015906105b95750600960ff821611155b156106bb5781545f906105d6908890610100900460ff168761045f565b83549091505f906105f290899062010000900460ff168861045f565b905060031960ff8416016106155761060a8183610f0a565b94505050505061026b565b60041960ff84160161062b5761060a8183610eb6565b60051960ff8416016106415761060a8183610f3c565b60061960ff8416016106575761060a8183610f1d565b60071960ff841601610692578060015f5b828110156106845761067a8583610f3c565b9150600101610668565b50955061026b945050505050565b60081960ff84160161003f57670de0b6b3a76400006106b18284610f3c565b61060a9190610f1d565b60111960ff8216016107205781545f906106df908890610100900460ff1687610bc6565b905080156107085782546106fe90889062010000900460ff168761045f565b935050505061026b565b82546106fe9088906301000000900460ff168761045f565b60121960ff821601610730575f80fd5b60131960ff82160161003f575f80fd5b5f600160ff83161161075357505f919050565b600360ff83161161076657506001919050565b601160ff83161161077957506002919050565b601360ff83161161078c57506003919050565b601460ff83161161003f57506004919050565b5f600160ff8416116107b357506001610bc0565b60011960ff8416016107fd576001825f815181106107d3576107d3610e70565b602002602001015160028111156107ec576107ec610ef6565b146107f5575f80fd5b506001610bc0565b60021960ff841601610847576002825f8151811061081d5761081d610e70565b6020026020010151600281111561083657610836610ef6565b1461083f575f80fd5b506002610bc0565b600460ff84161080159061085f5750600960ff841611155b156108af576001825f8151811061087857610878610e70565b6020026020010151600281111561089157610891610ef6565b1461089a575f80fd5b6001826001815181106107d3576107d3610e70565b600a60ff8416108015906108c75750600f60ff841611155b15610918576001825f815181106108e0576108e0610e70565b602002602001015160028111156108f9576108f9610ef6565b14610902575f80fd5b60015b8260018151811061081d5761081d610e70565b601060ff8416108015906109305750601160ff841611155b15610972576002825f8151811061094957610949610e70565b6020026020010151600281111561096257610962610ef6565b1461096b575f80fd5b6002610905565b60111960ff841601610a6d576002825f8151811061099257610992610e70565b602002602001015160028111156109ab576109ab610ef6565b146109b4575f80fd5b5f826001815181106109c8576109c8610e70565b602002602001015160028111156109e1576109e1610ef6565b036109ea575f80fd5b816002815181106109fd576109fd610e70565b60200260200101516002811115610a1657610a16610ef6565b82600181518110610a2957610a29610e70565b60200260200101516002811115610a4257610a42610ef6565b14610a4b575f80fd5b81600181518110610a5e57610a5e610e70565b60200260200101519050610bc0565b60121960ff841601610afb576001825f81518110610a8d57610a8d610e70565b60200260200101516002811115610aa657610aa6610ef6565b14610aaf575f80fd5b600182600181518110610ac457610ac4610e70565b60200260200101516002811115610add57610add610ef6565b14610ae6575f80fd5b6001826002815181106107d3576107d3610e70565b60131960ff84160161003f576001825f81518110610b1b57610b1b610e70565b60200260200101516002811115610b3457610b34610ef6565b14610b3d575f80fd5b600182600181518110610b5257610b52610e70565b60200260200101516002811115610b6b57610b6b610ef6565b14610b74575f80fd5b600182600281518110610b8957610b89610e70565b60200260200101516002811115610ba257610ba2610ef6565b14610bab575f80fd5b6001826003815181106107d3576107d3610e70565b92915050565b5f80848460ff1681548110610bdd57610bdd610e70565b5f9182526020909120600290910201805490915060ff166002198101610c1d578154610c13908790610100900460ff1686610bc6565b159250505061026b565b600a60ff821610801590610c355750600f60ff821611155b15610cfd5781545f90610c52908890610100900460ff168761045f565b83549091505f90610c6e90899062010000900460ff168861045f565b905060091960ff841601610c875714925061026b915050565b600a1960ff841601610c9f571415925061026b915050565b600b1960ff841601610cb65711925061026b915050565b600c1960ff841601610ccd5710925061026b915050565b600d1960ff841601610ce5571015925061026b915050565b600e1960ff84160161003f571115925061026b915050565b601060ff821610801590610d155750601160ff821611155b15610d9d5781545f90610d32908890610100900460ff1687610bc6565b9050600f1960ff831601610d68578015610d5d5782546106fe90889062010000900460ff1687610bc6565b5f935050505061026b565b60101960ff83160161003f578015610d86576001935050505061026b565b82546106fe90889062010000900460ff1687610bc6565b60111960ff82160161003f5781545f90610dc1908890610100900460ff1687610bc6565b90508015610de05782546106fe90889062010000900460ff1687610bc6565b82546106fe9088906301000000900460ff1687610bc6565b5f805f60408486031215610e0a575f80fd5b83359250602084013567ffffffffffffffff80821115610e28575f80fd5b818601915086601f830112610e3b575f80fd5b813581811115610e49575f80fd5b8760208260051b8501011115610e5d575f80fd5b6020830194508093505050509250925092565b634e487b7160e01b5f52603260045260245ffd5b634e487b7160e01b5f52601160045260245ffd5b5f60ff821660ff8103610ead57610ead610e84565b60010192915050565b81810381811115610bc057610bc0610e84565b634e487b7160e01b5f52604160045260245ffd5b60ff8181168382160190811115610bc057610bc0610e84565b634e487b7160e01b5f52602160045260245ffd5b80820180821115610bc057610bc0610e84565b5f82610f3757634e487b7160e01b5f52601260045260245ffd5b500490565b8082028115828204841417610bc057610bc0610e8456fea2646970667358221220d6e31d80cf1560547921e1feb726910fc33a39a396aad577a64e99758d23d93264736f6c63430008180033",
  "deployedBytecode": "0x730000000000000000000000000000000000000000301460806040526004361061003f575f3560e01c80638e501fc714610043578063b15b56f514610064575b5f80fd5b81801561004e575f80fd5b5061006261005d366004610df8565b610089565b005b610077610072366004610df8565b61022a565b60405190815260200160405180910390f35b825415610094575f80fd5b61010081106100a1575f80fd5b5f5b60ff81168211156101f9575f83838360ff168181106100c4576100c4610e70565b905060200201359050601560ff1681106100dc575f80fd5b6040805160c0810182525f60208201819052918101829052606081018290526080810182905260a081019190915260ff8216815281158061011d5750600182145b1561015157848461012d85610e98565b94508460ff1681811061014257610142610e70565b602002919091013560a0830152505b8554600180820188555f888152602090819020845160029094020180549185015160408601516060870151608088015160ff97881661ffff1990961695909517610100938816939093029290921763ffff00001916620100009187169190910263ff0000001916176301000000918616919091021764ff000000001916640100000000949092169390930217825560a090920151910155506101f281610e98565b90506100a3565b505f610205845f610272565b50845490915061021790600190610eb6565b8160ff1614610224575f80fd5b50505050565b5f610268845f8585808060200260200160405190810160405280939291908181526020018383602002808284375f9201919091525061045f92505050565b90505b9392505050565b81545f90819060ff841610610285575f80fd5b5f848460ff168154811061029b5761029b610e70565b5f91825260208220600290910201805490925060ff16906102bb82610740565b90505f8160ff1667ffffffffffffffff8111156102da576102da610ec9565b604051908082528060200260200182016040528015610303578160200160208202803683370190505b509050865f5b8360ff168160ff161015610442578060ff165f036103475761032c826001610edd565b865460ff919091166101000261ff00199091161786556103e2565b8060ff1660010361037a5761035d826001610edd565b865460ff91909116620100000262ff0000199091161786556103e2565b8060ff166002036103af57610390826001610edd565b865460ff9190911663010000000263ff000000199091161786556103e2565b8060ff1660030361003f576103c5826001610edd565b865460ff919091166401000000000264ff00000000199091161786555b6103f68a6103f1846001610edd565b610272565b848360ff168151811061040b5761040b610e70565b6020026020010181600281111561042457610424610ef6565b600281111561043557610435610ef6565b9052509150600101610309565b505f61044e858461079f565b919a91995090975050505050505050565b5f80848460ff168154811061047657610476610e70565b5f9182526020909120600290910201805490915060ff168061049e575060010154905061026b565b5f1960ff8216016105215783518260010154106104fa5760405162461bcd60e51b8152602060048201526016602482015275092dcecc2d8d2c840ecc2e4d2c2c4d8ca40d2dcc8caf60531b604482015260640160405180910390fd5b8382600101548151811061051057610510610e70565b60200260200101519250505061026b565b60011960ff8216016105a15781545f90610545908890610100900460ff168761045f565b90505f6002610555836001610f0a565b61055f9190610f1d565b9050815b8082101561059557508060028161057a8186610f1d565b6105849190610f0a565b61058e9190610f1d565b9150610563565b945061026b9350505050565b600460ff8216108015906105b95750600960ff821611155b156106bb5781545f906105d6908890610100900460ff168761045f565b83549091505f906105f290899062010000900460ff168861045f565b905060031960ff8416016106155761060a8183610f0a565b94505050505061026b565b60041960ff84160161062b5761060a8183610eb6565b60051960ff8416016106415761060a8183610f3c565b60061960ff8416016106575761060a8183610f1d565b60071960ff841601610692578060015f5b828110156106845761067a8583610f3c565b9150600101610668565b50955061026b945050505050565b60081960ff84160161003f57670de0b6b3a76400006106b18284610f3c565b61060a9190610f1d565b60111960ff8216016107205781545f906106df908890610100900460ff1687610bc6565b905080156107085782546106fe90889062010000900460ff168761045f565b935050505061026b565b82546106fe9088906301000000900460ff168761045f565b60121960ff821601610730575f80fd5b60131960ff82160161003f575f80fd5b5f600160ff83161161075357505f919050565b600360ff83161161076657506001919050565b601160ff83161161077957506002919050565b601360ff83161161078c57506003919050565b601460ff83161161003f57506004919050565b5f600160ff8416116107b357506001610bc0565b60011960ff8416016107fd576001825f815181106107d3576107d3610e70565b602002602001015160028111156107ec576107ec610ef6565b146107f5575f80fd5b506001610bc0565b60021960ff841601610847576002825f8151811061081d5761081d610e70565b6020026020010151600281111561083657610836610ef6565b1461083f575f80fd5b506002610bc0565b600460ff84161080159061085f5750600960ff841611155b156108af576001825f8151811061087857610878610e70565b6020026020010151600281111561089157610891610ef6565b1461089a575f80fd5b6001826001815181106107d3576107d3610e70565b600a60ff8416108015906108c75750600f60ff841611155b15610918576001825f815181106108e0576108e0610e70565b602002602001015160028111156108f9576108f9610ef6565b14610902575f80fd5b60015b8260018151811061081d5761081d610e70565b601060ff8416108015906109305750601160ff841611155b15610972576002825f8151811061094957610949610e70565b6020026020010151600281111561096257610962610ef6565b1461096b575f80fd5b6002610905565b60111960ff841601610a6d576002825f8151811061099257610992610e70565b602002602001015160028111156109ab576109ab610ef6565b146109b4575f80fd5b5f826001815181106109c8576109c8610e70565b602002602001015160028111156109e1576109e1610ef6565b036109ea575f80fd5b816002815181106109fd576109fd610e70565b60200260200101516002811115610a1657610a16610ef6565b82600181518110610a2957610a29610e70565b60200260200101516002811115610a4257610a42610ef6565b14610a4b575f80fd5b81600181518110610a5e57610a5e610e70565b60200260200101519050610bc0565b60121960ff841601610afb576001825f81518110610a8d57610a8d610e70565b60200260200101516002811115610aa657610aa6610ef6565b14610aaf575f80fd5b600182600181518110610ac457610ac4610e70565b60200260200101516002811115610add57610add610ef6565b14610ae6575f80fd5b6001826002815181106107d3576107d3610e70565b60131960ff84160161003f576001825f81518110610b1b57610b1b610e70565b60200260200101516002811115610b3457610b34610ef6565b14610b3d575f80fd5b600182600181518110610b5257610b52610e70565b60200260200101516002811115610b6b57610b6b610ef6565b14610b74575f80fd5b600182600281518110610b8957610b89610e70565b60200260200101516002811115610ba257610ba2610ef6565b14610bab575f80fd5b6001826003815181106107d3576107d3610e70565b92915050565b5f80848460ff1681548110610bdd57610bdd610e70565b5f9182526020909120600290910201805490915060ff166002198101610c1d578154610c13908790610100900460ff1686610bc6565b159250505061026b565b600a60ff821610801590610c355750600f60ff821611155b15610cfd5781545f90610c52908890610100900460ff168761045f565b83549091505f90610c6e90899062010000900460ff168861045f565b905060091960ff841601610c875714925061026b915050565b600a1960ff841601610c9f571415925061026b915050565b600b1960ff841601610cb65711925061026b915050565b600c1960ff841601610ccd5710925061026b915050565b600d1960ff841601610ce5571015925061026b915050565b600e1960ff84160161003f571115925061026b915050565b601060ff821610801590610d155750601160ff821611155b15610d9d5781545f90610d32908890610100900460ff1687610bc6565b9050600f1960ff831601610d68578015610d5d5782546106fe90889062010000900460ff1687610bc6565b5f935050505061026b565b60101960ff83160161003f578015610d86576001935050505061026b565b82546106fe90889062010000900460ff1687610bc6565b60111960ff82160161003f5781545f90610dc1908890610100900460ff1687610bc6565b90508015610de05782546106fe90889062010000900460ff1687610bc6565b82546106fe9088906301000000900460ff1687610bc6565b5f805f60408486031215610e0a575f80fd5b83359250602084013567ffffffffffffffff80821115610e28575f80fd5b818601915086601f830112610e3b575f80fd5b813581811115610e49575f80fd5b8760208260051b8501011115610e5d575f80fd5b6020830194508093505050509250925092565b634e487b7160e01b5f52603260045260245ffd5b634e487b7160e01b5f52601160045260245ffd5b5f60ff821660ff8103610ead57610ead610e84565b60010192915050565b81810381811115610bc057610bc0610e84565b634e487b7160e01b5f52604160045260245ffd5b60ff8181168382160190811115610bc057610bc0610e84565b634e487b7160e01b5f52602160045260245ffd5b80820180821115610bc057610bc0610e84565b5f82610f3757634e487b7160e01b5f52601260045260245ffd5b500490565b8082028115828204841417610bc057610bc0610e8456fea2646970667358221220d6e31d80cf1560547921e1feb726910fc33a39a396aad577a64e99758d23d93264736f6c63430008180033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "init(Equation.Node[] storage,uint256[])": {
        "details": "Initialize equation by array of opcodes/values in prefix order. Array is read as if it is the *pre-order* traversal of the expression tree."
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "calculate(Equation.Node[] storage,uint256[])": {
        "notice": "Calculate the Y position from the X position for this equation."
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}